<!DOCTYPE html>

<html lang="bg">
  <head>
    <meta charset="utf-8" />

    <title>A04 - Cartoon Network - 0MI0800653</title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #111;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
      import * as THREE from "three";

      const renderer = new THREE.WebGLRenderer({ antialias: true });

      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;

      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      scene.background = new THREE.Color(0x101018);

      const camera = new THREE.PerspectiveCamera(
        40,
        innerWidth / innerHeight,
        0.1,
        100
      );

      camera.position.set(0, 6, 20);
      camera.lookAt(0, 4, 0);

      scene.add(new THREE.AmbientLight(0xffffff, 0.35));

      const key = new THREE.DirectionalLight(0xffffff, 1.0);

      key.position.set(6, 10, 8);
      key.castShadow = true;
      key.shadow.mapSize.set(1024, 1024);

      scene.add(key);

      const rim = new THREE.DirectionalLight(0x88aaff, 0.4);

      rim.position.set(-8, 6, -6);
      scene.add(rim);

      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 40),
        new THREE.MeshStandardMaterial({
          color: 0x181822,
          roughness: 0.9,
          metalness: 0.0,
        })
      );

      floor.rotation.x = -Math.PI / 2;
      floor.position.y = 0;
      floor.receiveShadow = true;

      scene.add(floor);

      function createFlangeGeometry() {
        const outerR = 1.0;
        const innerR = 0.55;
        const holeR = 0.18;

        const flangeShape = new THREE.Shape();

        flangeShape.absarc(0, 0, outerR, 0, Math.PI * 2, false);

        const innerHole = new THREE.Path();

        innerHole.absarc(0, 0, innerR, 0, Math.PI * 2, true);
        flangeShape.holes.push(innerHole);

        const holePositions = [
          [outerR * 0.55, 0],
          [-outerR * 0.55, 0],
          [0, outerR * 0.55],
          [0, -outerR * 0.55],
        ];

        for (const [hx, hy] of holePositions) {
          const h = new THREE.Path();
          h.absarc(hx, hy, holeR, 0, Math.PI * 2, true);
          flangeShape.holes.push(h);
        }

        const extrudeSettings = {
          depth: 0.25,
          bevelEnabled: true,
          bevelSize: 0.03,
          bevelThickness: 0.04,
          bevelSegments: 3,
          steps: 1,
        };

        return new THREE.ExtrudeGeometry(flangeShape, extrudeSettings);
      }

      const flangeGeometry = createFlangeGeometry();
      flangeGeometry.computeVertexNormals();

      const flangeMaterial = new THREE.MeshStandardMaterial({
        color: 0xd0d5de,
        metalness: 0.9,
        roughness: 0.18,
        envMapIntensity: 1.0,
      });

      const logoGroup = new THREE.Group();
      scene.add(logoGroup);

      const baseY = 4;

      const plateGeom = new THREE.BoxGeometry(6, 6, 0.4);

      const plateC = new THREE.Mesh(
        plateGeom,
        new THREE.MeshStandardMaterial({
          color: 0x000000,
          metalness: 0.1,
          roughness: 0.7,
        })
      );

      plateC.position.set(-3.4, baseY, 0);
      plateC.castShadow = true;
      plateC.receiveShadow = true;

      logoGroup.add(plateC);

      const plateN = new THREE.Mesh(
        plateGeom,
        new THREE.MeshStandardMaterial({
          color: 0xf5f5f5,
          metalness: 0.1,
          roughness: 0.6,
        })
      );

      plateN.position.set(3.4, baseY, 0);
      plateN.castShadow = true;
      plateN.receiveShadow = true;

      logoGroup.add(plateN);

      function addFlangeLetter(parent, gridX, gridY, plateOffsetX) {
        const spacing = 1.1;
        const mesh = new THREE.Mesh(flangeGeometry, flangeMaterial);

        mesh.position.set(
          plateOffsetX + gridX * spacing,
          baseY + gridY * spacing,
          0.25
        );

        mesh.castShadow = true;
        mesh.receiveShadow = true;

        parent.add(mesh);
      }

      const patternC = [
        [-2, 2],
        [-1, 2],
        [0, 2],
        [1, 2],
        [-2, 1],
        [-2, 0],
        [-2, -1],
        [-2, -2],
        [-1, -2],
        [0, -2],
        [1, -2],
      ];

      const patternN = [
        [-2, -2],
        [-2, -1],
        [-2, 0],
        [-2, 1],
        [-2, 2],
        [-1, -1],
        [0, 0],
        [1, 1],
        [2, -2],
        [2, -1],
        [2, 0],
        [2, 1],
        [2, 2],
      ];

      for (const [gx, gy] of patternC) {
        addFlangeLetter(logoGroup, gx, gy, -3.4);
      }

      for (const [gx, gy] of patternN) {
        addFlangeLetter(logoGroup, gx, gy, 3.4);
      }

      logoGroup.position.set(0, 0, 0);
      logoGroup.rotation.set(0, 0, 0);

      let t0 = performance.now();
      renderer.setAnimationLoop(draw);

      function draw(t) {
        const dt = (t - t0) / 1000;
        t0 = t;

        logoGroup.rotation.y = Math.sin(t * 0.0004) * 0.12;

        camera.lookAt(0, baseY, 0);
        renderer.render(scene, camera);
      }

      addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
